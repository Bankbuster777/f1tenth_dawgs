import os
import yaml, time
import numpy as np
import pandas as pd
import cvxpy as cp

# == User input ==
script_dir = os.path.dirname(os.path.abspath(__file__))
map_dir = script_dir + "/../../peripheral/racetracks/"
map_name = "Shanghai/Shanghai_"

yaml_path = os.path.join(map_dir, map_name + "map.yaml")
png_path = os.path.join(map_dir, map_name + "map.png")

csv_path = os.path.join(map_dir, map_name + "frenet_track.csv") # centerline
out_path = os.path.join(map_dir, map_name + "kappa_speedopted.csv") # centerline

# 1. Load YAML
with open(yaml_path, 'r') as f:
    map_yaml = yaml.safe_load(f)

resolution = map_yaml["resolution"]
origin = map_yaml["origin"][:2]

# 2. Load path
def load_path(path='path_xy.csv'):
    df = pd.read_csv(path)
    if {'x','y'}.issubset(df.columns):
        x = df['x'].to_numpy()
        y = df['y'].to_numpy()
    else:
        arr = df.to_numpy()
        x, y = arr[:,0], arr[:,1]
    return x, y

def make_uniform_theta(n):
    # theta_0=0, theta_{n-1}=1, even spaced
    theta = np.linspace(0.0, 1.0, n)
    dtheta = theta[1] - theta[0]
    return theta, dtheta

def compute_ds(x, y):
    dx = np.diff(x)
    dy = np.diff(y)
    ds = np.sqrt(dx**2 + dy**2)
    s = np.concatenate([[0.0], np.cumsum(ds)])
    return s, ds

def compute_curvatures(x,y):
    n=len(x); kappa=np.zeros(n)
    for i in range(1,n-1):
        xm,ym=x[i-1],y[i-1]; x0,y0=x[i],y[i]; xp,yp=x[i+1],y[i+1]
        dx1,dy1=x0-xm,y0-ym; dx2,dy2=xp-x0,yp-y0
        ds1=np.hypot(dx1,dy1); ds2=np.hypot(dx2,dy2)
        if ds1<1e-8 or ds2<1e-8: continue
        xdot=(dx1/ds1+dx2/ds2)/2; ydot=(dy1/ds1+dy2/ds2)/2
        xdd=(dx2/ds2-dx1/ds1)/((ds1+ds2)/2)
        ydd=(dy2/ds2-dy1/ds1)/((ds1+ds2)/2)
        denom=(xdot**2+ydot**2)**1.5
        if denom>0: kappa[i]=(xdot*ydd-ydot*xdd)/denom
    kappa[0]=kappa[1]; kappa[-1]=kappa[-2]
    return kappa

def solve_speed_profile(x,y,mu=0.9,g=9.81,vmax=15.0,a_max=6.0,a_min=-4.0,v_init=0):
    n=len(x)
    s,ds=compute_ds(x,y)
    kappa=compute_curvatures(x,y)

    b_max=np.full(n,vmax**2)
    for i in range(n):
        if abs(kappa[i])>1e-6:
            b_max[i]=min(b_max[i], (mu*g)/abs(kappa[i]))

    b=cp.Variable(n,pos=True)
    # autogenerated
    obj = cp.sum(cp.multiply(np.concatenate([ds,[0]]), cp.power(b,-0.5)))
    # obj = cp.sum( 2*ds / (cp.sqrt(b[:-1]) + cp.sqrt(b[1:])) )
    constraints=[b[0]==v_init**2]
    # b[0] = (v_init)**2
    for i in range(n):
        constraints+=[b[i]<=b_max[i], b[i]>=1e-6]
    for i in range(1,n):
        constraints+=[(b[i]-b[i-1])/(2*ds[i-1])<=a_max,
                      (b[i]-b[i-1])/(2*ds[i-1])>=a_min]

    prob=cp.Problem(cp.Minimize(obj),constraints)
    prob.solve(solver=cp.ECOS, warm_start=True, verbose=True) # ECOS, SCS, OSQP
    v=np.sqrt(np.maximum(b.value,0))
    return v,s,kappa

def main():
    start_time = time.time()
    x,y=load_path(csv_path)
    v,s,kappa=solve_speed_profile(x,y)

    end_time = time.time()

    df_out=pd.DataFrame({'x':x,'y':y,'v':v,'kappa':kappa,'s':s})
    df_out.round({
        'x':3,
        'y':3,
        'v':3,
        'kappa':4,
        's':4
    }).to_csv(out_path,index=False)

    print("Saved to:", out_path)
    print(f"Time spend: {end_time - start_time:.2f}sec")


if __name__=="__main__":
    main()
